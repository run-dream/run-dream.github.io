```
layout: post
date: 2021-11-12 23:30
category: 并发编程
tags:
  - Node.js
  - Redis
```

### 从单线程模型说起

#### 到底是怎么个单线程

我们知道 Node.js 和 Redis 都是部分基于**单线程**模型的。

具体来说 Node.js 只有一个 JavaScript 线程，而 Redis 对核心网络模型和键值的读写是单线程的。

Redis v4.0 为了解决删除超大的键值对引起的阻塞问题，引入多线程处理异步任务。Redis v6.0 正式在网络模型中实现 I/O 多线程， 不过只负责网络 I/O 和命令解析部分，命令执行部分仍然是由主线程处理的，目的是解决Redis  的网络 I/O 瓶颈。

#### 并行处理请求工作的方式

我们同时也知道现代 Web 应用中，并发是必须提供的能力，也就是说必须尽可能的减少阻塞。常见的并行处理请求工作的方式有：

1. **多进程方式**。为每个请求启动一个进程，但是因为系统资源有限，不具有扩展性。如初期的 Apache就采用了这种方式。 
2. **多线程方式**。为每个请求启动一个线程，虽然线程比进程要轻量，但是大并发请求到来时，资源还是很快用尽，导致服务缓慢。 IIS 服务器采用的是这种方式，IIS 会定期重启服务。
3. **异步方式。**发送方发出一个请求后，不等待接收方响应这个请求，就继续发送下一个请求。

#### 为什么它们采用了单线程模型呢？

从实际场景来说：

Node.js 来说要保持JavaScript在浏览器中单线程的特点采用了单线程。对于Redis 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型。如果不考虑 RDB/AOF 等持久化方案，Redis 是完全的纯内存操作，执行速度是非常快的。Redis 真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis 选择了单线程的 I/O 多路复用来实现它的核心网络模型。

从单线程的好处来说：

避免了过多的上下文切换。多线程调度过程中必然需要在 CPU 之间切换线程上下文 context，而上下文的切换又涉及程序计数器、堆栈指针和程序状态字等一系列的寄存器置换、程序堆栈重置甚至是 CPU 高速缓存、TLB 快表的汰换。

避免同步机制的开销，只有一个线程就不用考虑锁的问题。

简单可维护。Redis 的作者一直秉承这个理念。

### 单线程模型下如何处理并发请求

IO是昂贵的，分布式IO则是更昂贵的。幸好，在计算机资源中，IO与CPU计算之间是可以并行进行的。通过引入 **异步IO** 让单线程远离阻塞，从而更好的利用CPU。

#### 操作系统对IO的支持

操作系统提供了阻塞/非阻塞IO，阻塞IO造成CPU等待浪费，非阻塞带来的麻烦是需要轮询确认IO完成的状态，也是对CPU资源的浪费。

相关的系统调用有

- **read** 通过**重复调用**来检查IO的状态，CPU一直耗用在等待上。

- **select** 采用了**数组**fd_set来表示文件描述符, 存在最大文件描述符数量限制。且每次调用都需要把 fd 集合从用户态拷贝到内核态。

- **poll** 用**链表**pollfd的方式解决了最大文件描述符数量限制。

- **epoll** 则不需要遍历，采用的是**回调机制**，通过三个系统调用

  - **epoll_create** 创建一个 epoll 实例并返回 epollfd
  - **epoll_ctl** 注册 file descriptor 等待的 I/O 事件(比如 EPOLLIN、EPOLLOUT 等) 到 epoll **红黑树**实例上
  - **epoll_wait** 则是阻塞监听 epoll 实例上所有的 file descriptor 的 I/O 事件，它接收一个用户空间上的一块内存地址 (events 数组)，kernel 会在有 I/O 事件发生的时候把文件描述符列表复制到这块内存地址上，然后 epoll_wait 解除阻塞并返回，最后用户空间上的程序就可以对相应的 fd 进行读写了。

  epoll的优势在于分清了高频调用和低频调用，直接返回已就绪 fd，并减少了数据在用户态和内核态之间的复制。

#### Node.js 的异步机制



#### Redis 的 Reactor 设计模式



### 参考资料


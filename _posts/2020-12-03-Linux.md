---
layout: post
date: 2020-12-03 16:00:00
category: Linux
tags:
  - Linux
  - 操作系统
---

## 基本结构

### 硬件

硬件只有在操作系统的控制下才能完成工作

组成：

- CPU 
- 内存 RAM 
- 磁盘
- 主板
- 输入设备 鼠标 键盘 摄像头 麦克风 
- 输出设备 屏幕 影响



### 操作系统

操作系统是管理计算机硬件与软件资源的计算机程序。

![结构](https://run-dream.github.io/img/post/os.png)



## 常用命令

### 帮助文档

```bash
man <cmd>
<cmd> -h
```

### 用户和密码

用户和用户组属于多对多关系，一个用户可以同时属于多个用户组，一个用户组可以包含多个不同用户。

```bash
useradd xxx -u <uid> -p <password>
```

相关文件

- /etc/passwd 用户列表

  每行记录的格式为

  ```
   <account>:<password=x>:<uid>:<gid>:<name>:<home>:<shell>	
  ```

- /etc/group 组id

- /home/xxx 用户目录
- /etc/shadow 用户密码 只有root能看到

### 浏览文件

```bash
# 列出文件
ls -l
# 输出为 drwxr-xr-x 6 root root 4096 Oct 20 2020 apt
# 文件模式+权限位 硬链接数目 所属用户 所属组 文件大小 最近被修改日期 文件名

# 修改权限
chmod <mode> <file>

# 修改所属用户
chown <user> <file>

# 修改所属组
chgrp <group> <file>
```

文件权限

| 支持指令  | 文件         | 文件夹          |
| --------- | ------------ | --------------- |
| x  可执行 | ./FILE       | cd DIR          |
| w 可写    | cat FILE + S | midir/touch DIR |
| r 可读    | cat FILE     | ls DIR          |

### 安装软件
  1. 包管理工具
     - rpm CentOS体系

       ```bash
       # 基础方式 (Redhat Package Manager)
       rpm -i xxx.rpm # 安装
       rpm -qa # list
       rpm -e xxx # 卸载
       
       # 软件管理包 (Yellow dog Updater,Modifier)
       yum search xxx # 查找版本
       yum install xxx # 安装
       yum list # list
       yum remove xxx # 卸载
       yum update xxx # 更新
       ```

       下载地址配置文件 /etc/yum.repos.d/CentOS-Base.repo

       ```tx
       [base]
       name=CentOS-$releasever - Base - 163.com
       baseurl=http://mirrors.163.com/centos/$releasever/os/$basearch/
       gpgcheck=1
       gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7
       ```

     - deb Ubuntu体系

       ```bash
       # 基础方式(Debian PacKaGe)
       dpkg -i xxx.deb  # 安装
       dpkg -l # list
       dpkg -r xxx.debg # 卸载
       dpkg -r --purge xxx.deb  #连同配置文件一起卸载
       
       # 软件管理包(Advance Packaging Tool)
       apt-get install xxx # 安装
       apt-get update # 更新
       apt-get remove # 卸载
       apt-get list #列出
       
       ```

       下载地址配置文件 /etc/apt/sources.list

       ```tx
       
       deb http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse
       deb http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse
       deb http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse
       deb http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse
       deb http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse
       ```

  2. 下载解压缩
     - .bashrc
     - 环境变量 export

#### 安装目录

一般规范

| 功能         | 目录                    |
| ------------ | ----------------------- |
| 主执行文件   | /usr/bin 或者 /usr/sbin |
| 其他的库文件 | /var                    |
| 配置文件     | /etc                    |

### 运行程序

- 前台运行 

  ```bash
  cd <dir>
  ./<filename>
  ```

  设置PATH变量以后可以直接

  ```bash
  <filename>
  ```


- 后台运行(no hang up)

  ```bash
  # nohup 表示不挂掉 即使命令行退出 进程也还是保留
  # & 表示在后台运行
  nohup <command> &
  ```

  关闭程序

  ```bash
  # xargs 用户将前面的输出结果 作为参数传给后续命令
  # kill -9 表示强制杀死该进程 9是linux信号量SIGKILL 不传 9 默认是 SIGTERM 15
  ps -ef | grep <key>  | awk '{print $2}'| xargs kill -9
  ```

- 以服务的方式运行 service [systemd](http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html)

  service命令其实是去/etc/init.d目录下，去执行相关程序。

  而systemctl 实际上将service 和chkconfig 这两个命令组合到一起。systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。

  ```bash
  # service命令其实是去/etc/init.d目录下，去执行相关程序
  service httpd start   # 启动
  service httpd stop    # 终止
  service httpd restart # 重启
  service httpd status  # 查看状态
  
  # systemctl命令
  systemctl start httpd.service   # 启动
  systemctl stop httpd.service    # 终止
  systemctl restart httpd.service # 重启
  systemctl status httpd.service  # 查看状态
  systemctl enable httpd.service  # 使某服务自动启动
  ```


### 编辑文本

- vi/vim
  - i(insert）
  - q(quit)
  - q!(quit without save)
  - esc w
- gedit  



##  系统调用

### 进程管理

#### 概念

- 父进程 

  除了pid=0的交换进程以外，所有进程都是由pid=1的初始进程fork出来的(systemd/initd)

- 子进程

#### 系统调用

- fork  复制进程

  当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。对于 fork 系统调用的返回值，如果当前进程是子进程，就返回 0；如果当前进程是父进程，就返回子进程的进程号。

- execve 执行另一个程序
- waitpid 暂时停止目前进程的执行，直到有信号来到或子进程结束。

### 内存管理

#### 概念

- 独立进程空间 

  操作系统中，每个进程都有自己的内存，互相之间不干扰。最大大小和CPU位数相关，32位操作系统为Math.pow(2,32) = 4G

- 代码段 

  进程的内存空间中存放程序代码的这部分

- 数据段

  进程的内存空间中存放进程运行中产生数据的这部分

- 堆

  动态分配的，会较长时间保存，指明才销毁的数据段

#### 系统调用

- brk 直接修改有效访问范围的末尾地址实现分配与回收。适合少量内存分配。
- mmap 在进程的虚拟地址空间中找一块空闲的虚拟内存。适合大量内存分配。



### 文件管理

Linux 里有一个特点，那就是一切皆文件。程序是二进制文件，配置是文本文件，控制台是stdout文件，管道也是文件，socket也是文件，设备也是文件，文件夹也是文件，进程号pid也是文件。

每个文件，Linux 都会分配一个文件描述符，作为系统调用的参数

#### 概念

- 介质
- 格式

#### 系统调用

- open 打开存在的文件
- close 关闭存在的文件
- creat 新建不存在的文件
- lseek 调到文件某个位置
- read 读
- write 写



### 信号处理

#### 概念

当出现异常时，会产生信号通知等待进程。

#### 系统调用

- sigaction 注册一个信号处理函数



#### 进程间通信

1. 消息队列 在内核里 消息比较短

   - msgget 创建一个新的队列
   - msgsnd 将消息发送到消息队列
   - msgrcv 从队列中取消息

2. 共享内存  不需要拷贝

   - shmget 创建一个共享内存块
   - shmat 将共享内存映射到自己的内存空间

3. 信号量  Semaphore 处理竞争问题

   - sem_wait 占用这个信号量  操作系统的 P 操作

     信号量大于零，就给它减1；信号量为零，就挂起该进程的执行

   - sem_pos 释放信号量 

     如果有其他进程因等待信号量而被挂起，就让它恢复运行，如果没有0，就给它加1

4. 信号

5. 管道

6. 套接字 socket

## 初始化

### x86架构

![总线](https://run-dream.github.io/img/post/system.png)

![CPU](https://run-dream.github.io/img/post/cpu.png)

- x86架构是指以8086为起始的intel的cpu标准，内部有 8 个 16 位的通用寄存器，20位地址总线
- 32位处理器有 32 根地址总线。系统启动时使用*实模式*，终止时使用*保护模式*

### 启动

![启动](https://run-dream.github.io/img/post/setup.png)

- 实模式只有1MB内存寻址空间(x86)

- 加电，重置CS为0xFFFF,IP为0x0000,对应BIOS程序

- 切换到保护模式需要做以下三件事

  1. 启用分段，辅助进程管理
  2. 启用分页，辅助内存管理
  3. 打开其他地址线

### 内核初始化

[代码](https://elixir.bootlin.com/linux/latest/source/init/main.c)

#### 创建样板进程, 及各个模块初始化

- 创建第一个进程, 0号进程. `INIT_TASK`
- 初始化中断, `trap_init()`.  系统调用也是通过发送中断进行, 由 `set_system_intr_gate()` 完成.
- 初始化内存管理模块, `mm_init()`
- 初始化进程调度模块, `sched_init()`
- 初始化基于内存的文件系统 rootfs, `vfs_caches_init()`
- 调用 `rest_init()` 完成其他初始化工作

#### 创建管理/创建用户态进程的进程, 1号进程

- `rest_init()` 通过 `kernel_thread(kernel_init,...)` 创建 1号进程(工作在用户态).
- 权限管理        
  - x86 提供 4个 Ring 分层权限        
  -  操作系统利用: Ring0-内核态(访问核心资源); Ring3-用户态(普通程序)
-  用户态调用系统调用: 用户态-系统调用-保存寄存器-内核态执行系统调用-恢复寄存器-返回用户态
-  新进程执行 kernel_init 函数, 先运行 ramdisk 的 /init 程序(位于内存中)
  -  首先加载 ELF 文件 (Executable and Linkable Format，可执行与可链接格式)
  -  设置用于保存用户态寄存器的结构体 
  -  返回进入用户态  
  -  ramdisk的 /init 加载存储设备的驱动
  -  kernel_init 函数启动存储设备文件系统上的 init

#### 创建管理/创建内核态进程的进程, 2号进程

- `rest_init()` 通过 `kernel_thread(kthreadd,...)` 创建 2号进程(工作在内核态).    
-  `kthreadd` 负责所有内核态线程的调度和管理





### 系统调用

![syscall](https://run-dream.github.io/img/post/syscall.png)



## 进程管理

### [什么是进程](https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)

进程就是运行中的程序，在linux中有三类进程

- init进程 用户态 不带括号
- 内核线程 kethradd 内核态 带括号[]
- 用户进程 

tty 那一列，是问号的，说明不是前台启动的，一般都是后台的服务。

多进程缺点:  创建进程占用资源多; 进程间通信需拷贝内存, 不能共享

### 线程

 一条线程指的是进程中一个单一顺序的控制流。

#### 线程的数据细分成三类：

1. 线程栈上的本地数据，每个线程都有自己的栈空间，默认大小为8M （针对于单个函数）
2. 整个进程里共享的全局数据，可能冲突
3. 线程私有数据

#### 共享数据的保护机制

mutex 在共享数据访问的时候，去申请加把锁

1.  lock(没抢到则阻塞)
2.  trylock(没抢到则返回错误码); 
3.  条件变量(通知), 收到通知, 还是要抢锁(由 wait 函数执行); 因此条件变量与互斥锁配合使用   



### 对应数据结构

内核中进程, 线程统一为任务, 由 task_struct 表示  通过链表串起 task_struct

对于一个正在运行的进程，可以通过以下命令行查看进程详细信息

```bash
ps 
cat /proc/pid
```

 ![进程数据结构](https://run-dream.github.io/img/post/linux-process-struct.jpeg)

- 任务ID 

  通过对比 pid 和 tgid 可判断是进程还是线程

- 任务状态

   ![任务状态](https://run-dream.github.io/img/post/linux_process_status.jpeg)

- 权限相关

  - real_cred 谁能操作此进程
  - cred  此进程能操作谁 *chmod*  
    - uid gid 启动
    - euid egid 生效
    - fsuid fsgid 文件

  capabilities 机制 

- 内核栈

  保存用户态运行过程中的 CPU 上下文

  ![内核栈](https://run-dream.github.io/img/post/linux-thread-info.jpeg)

  在内核态，32 位和 64 位的内核栈和 task_struct 的关联关系不同。32 位主要靠 thread_info，64 位主要靠 Per-CPU 变量。



### 调度

一个 CPU 上有一个队列，CFS 的队列是一棵红黑树，树的每一个节点都是一个 sched_entity，每个 sched_entity 都属于一个 task_struct，task_struct 里面有指针指向这个进程属于哪个调度类。

![任务调度](https://run-dream.github.io/img/post/linux-sched-struct.jpeg)

设置进程和线程的调度策略

```bash
 # 查看当前进程的调度策略
 chrt -p <pid>
 # 修改当前进度的调度优先级和策略
 chrt -f -p | -i | -o <priority> <pid>
```

1. 主动调度
2. 抢占调度

![主动调度](https://run-dream.github.io/img/post/linux-process-sched.png)

如何查看进程的运行时间和上下文切换次数

```bash
cat /proc/<pid>/sched
```



### 进程创建

fork

1. 将 task_struct 结构复制一份并且初始化
2. 试图唤醒新创建的子进程。

![fork](https://run-dream.github.io/img/post/linux-process-create.jpeg)



### 线程创建

线程不是一个完全由内核实现的机制，它是由内核态和用户态合作完成的。

pthread_create 不是一个系统调用，是 Glibc 库的一个函数。

- 内核态创建任务
- 用户态执行线程

创建进程的话，调用的系统调用是 fork，在 copy_process 函数里面，会将五大结构 files_struct、fs_struct、sighand_struct、signal_struct、mm_struct 都复制一遍，从此父进程和子进程各用各的数据结构。

而创建线程的话，调用的是系统调用 clone，在 copy_process 函数里面， 五大结构仅仅是引用计数加一，也即线程共享进程的数据结构。

![进程创建和线程创建的区别](https://run-dream.github.io/img/post/linux-thread-create.webp)



### [内存管理](https://jishuin.proginn.com/p/763bfbd248c0)

- 物理内存 只有内存管理模块可以操作

- 虚拟地址 每个进程看到的是独立的、互不干扰的虚拟地址空间

  - 内核空间 在高地址 内核 同一个内核空间
  - 用户空间 在低地址 普通进程 独占整个空间

- 用户态内存构成

  - Text Segment 存放二进制可执行代码
  - Data Segment  存放静态常量
  - BSS Segment 未初始化的静态变量
  - 堆（Heap）段 动态分配内存
  - Memory Mapping Segment 文件映射进内存
  - 栈（Stack）地址段  函数调用的函数栈

- 可以查看进程内存空间的布局的命令

  ```bash
  cat /proc/<pid>/map
  pmap <pid>
  ```

- 物理内存和虚拟地址映射

  - 分段机制 *Linux中段只被用于访问控制和内存保护。*

  ![分段机制](https://run-dream.github.io/img/post/linux-memory-segment.webp)

  - 分页机制 *Linux 主要使用分页的机制* *多级页表*

    	![分页机制](https://run-dream.github.io/img/post/linux-memry-page.webp)

  - 段页机制



### 进程空间管理

- 32位

  ![32位](https://run-dream.github.io/img/post/linux-process-memory-x32.webp)

- 64位

![64位](https://run-dream.github.io/img/post/linux-process-memory-x64.webp)

直接映射区: 这一块空间是连续的，和物理内存是非常简单的映射关系

查看虚拟内存和物理内存的映射关系

```bash
cat /proc/pid/pagemap
cat /proc/kpagecount
cat /proc/kpageflags
cat /proc/kpagecgroup
```

